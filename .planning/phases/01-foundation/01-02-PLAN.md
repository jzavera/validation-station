---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/context/validationReducer.ts
  - src/context/ValidationProvider.tsx
  - src/context/useValidation.ts
  - src/App.tsx
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "Dispatching SET_ACTIVE_FIELD from the browser console updates the activeFieldId in state"
    - "Dispatching NEXT_FIELD advances to the next field in fieldOrder"
    - "Dispatching PREV_FIELD moves to the previous field in fieldOrder"
    - "Dispatching SET_ZOOM changes the zoom level in state"
    - "Sample data loads into the ValidationProvider on app start"
  artifacts:
    - path: "src/context/validationReducer.ts"
      provides: "Reducer with all validation state actions"
      exports: ["validationReducer", "ValidationState", "ValidationAction"]
      contains: "SET_ACTIVE_FIELD"
    - path: "src/context/ValidationProvider.tsx"
      provides: "React Context provider wrapping the app with validation state"
      exports: ["ValidationProvider"]
    - path: "src/context/useValidation.ts"
      provides: "Custom hook to consume validation context"
      exports: ["useValidation"]
  key_links:
    - from: "src/context/validationReducer.ts"
      to: "src/types/extraction.ts"
      via: "typed import for Field, ExtractionResult"
      pattern: "import.*from.*types/extraction"
    - from: "src/context/ValidationProvider.tsx"
      to: "src/context/validationReducer.ts"
      via: "useReducer(validationReducer, initialState)"
      pattern: "useReducer.*validationReducer"
    - from: "src/context/ValidationProvider.tsx"
      to: "src/data/sampleData.ts"
      via: "imports sample data to initialize state"
      pattern: "import.*sampleExtractionResult.*from.*data/sampleData"
    - from: "src/App.tsx"
      to: "src/context/ValidationProvider.tsx"
      via: "wraps app content in ValidationProvider"
      pattern: "<ValidationProvider>"
---

<objective>
Build the centralized state management system (ValidationProvider with useReducer) and wire it into the app with sample data loaded, so that all state actions can be dispatched and verified from the browser console.

Purpose: This is the state backbone that every downstream phase depends on -- field navigation, editing, validation, and zoom all dispatch actions through this reducer. Getting it right here means all future phases plug in cleanly.
Output: ValidationProvider context, validationReducer with all actions, useValidation hook, and an App.tsx that loads sample data into state and exposes dispatch to the browser console for testing.
</objective>

<execution_context>
@/Users/bogdanzavera/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bogdanzavera/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation reducer with all state actions and types</name>
  <files>
    src/context/validationReducer.ts
  </files>
  <action>
    Create src/context/validationReducer.ts implementing the full state management logic.

    1. Define the ValidationState interface:
       ```typescript
       export interface ValidationState {
         result: ExtractionResult;
         fieldOrder: string[];       // flat array of field IDs in group order
         activeFieldId: string | null;
         isEditing: boolean;
         zoom: number;               // 1.0 = 100%
       }
       ```

    2. Define all action types as a discriminated union:
       ```typescript
       export type ValidationAction =
         | { type: 'SET_ACTIVE_FIELD'; fieldId: string }
         | { type: 'NEXT_FIELD' }
         | { type: 'PREV_FIELD' }
         | { type: 'START_EDIT' }
         | { type: 'CONFIRM_EDIT'; value: string }
         | { type: 'CANCEL_EDIT' }
         | { type: 'CONFIRM_FIELD' }
         | { type: 'MARK_MISSING' }
         | { type: 'SET_ZOOM'; zoom: number }
         | { type: 'ZOOM_IN' }
         | { type: 'ZOOM_OUT' };
       ```

    3. Create a helper function `buildFieldOrder(result: ExtractionResult): string[]` that flattens all field IDs from fieldGroups into a single ordered array. This determines Tab navigation order.

    4. Create a helper function `initializeState(result: ExtractionResult): ValidationState` that builds the initial state with fieldOrder computed and activeFieldId set to the first field.

    5. Implement the reducer function `validationReducer(state: ValidationState, action: ValidationAction): ValidationState`:

       - **SET_ACTIVE_FIELD**: Set activeFieldId to action.fieldId, set isEditing to false.
       - **NEXT_FIELD**: Find current index in fieldOrder, advance to next. If at end, stay at last. Set isEditing to false.
       - **PREV_FIELD**: Find current index in fieldOrder, go to previous. If at start, stay at first. Set isEditing to false.
       - **START_EDIT**: Set isEditing to true. Only works if activeFieldId is set.
       - **CONFIRM_EDIT**: Update the active field's extractedValue to action.value, increment dataVersion by 1, set validationSource to "user", set isEditing to false. Must find the field in result.fieldGroups and return a new immutable state (spread operators, not mutation).
       - **CANCEL_EDIT**: Set isEditing to false.
       - **CONFIRM_FIELD**: Set the active field's operatorConfirmed to true, validationSource to "user", set isEditing to false. Immutable update.
       - **MARK_MISSING**: Set the active field's isMissing to true. Immutable update.
       - **SET_ZOOM**: Set zoom to action.zoom, clamped between 0.25 and 4.0.
       - **ZOOM_IN**: Multiply zoom by 1.25, clamped to max 4.0.
       - **ZOOM_OUT**: Multiply zoom by 0.8, clamped to min 0.25.

    6. For actions that modify a field (CONFIRM_EDIT, CONFIRM_FIELD, MARK_MISSING), create a helper function `updateField(state: ValidationState, updater: (field: Field) => Field): ValidationState` that immutably updates the active field within the nested fieldGroups structure. This avoids code duplication.

    7. Export: validationReducer, ValidationState, ValidationAction, initializeState, buildFieldOrder.

    IMPORTANT: All state updates MUST be immutable (no mutation). Use spread operators and map() to create new arrays/objects.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- zero errors.
    Verify the file exports validationReducer, ValidationState, ValidationAction, initializeState.
  </verify>
  <done>
    validationReducer handles all 11 action types with immutable state updates. buildFieldOrder flattens field IDs from groups. initializeState creates a complete initial state from an ExtractionResult. All types are exported and compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ValidationProvider, useValidation hook, and wire into App with console testing</name>
  <files>
    src/context/ValidationProvider.tsx
    src/context/useValidation.ts
    src/App.tsx
    src/main.tsx
  </files>
  <action>
    1. Create src/context/ValidationProvider.tsx:
       - Create a React Context holding `{ state: ValidationState; dispatch: React.Dispatch<ValidationAction> }`.
       - The provider component accepts `children` and an `extractionResult: ExtractionResult` prop.
       - Use `useReducer(validationReducer, extractionResult, initializeState)` for lazy initialization.
       - Wrap children in the context provider, passing state and dispatch.
       - Export ValidationProvider and the context (for the hook to consume).

       ```typescript
       interface ValidationContextValue {
         state: ValidationState;
         dispatch: React.Dispatch<ValidationAction>;
       }
       ```

    2. Create src/context/useValidation.ts:
       - A custom hook that calls useContext on the validation context.
       - Throws a descriptive error if used outside a ValidationProvider: "useValidation must be used within a ValidationProvider".
       - Returns `{ state, dispatch }`.

    3. Update src/App.tsx:
       - Import ValidationProvider, useValidation, and sampleExtractionResult.
       - Wrap the app content in `<ValidationProvider extractionResult={sampleExtractionResult}>`.
       - Create an inner component (e.g., AppContent) that uses useValidation to read state.
       - Display a minimal debug view showing:
         - Active field ID
         - Current zoom level
         - Total fields count (from fieldOrder.length)
         - Whether isEditing is true/false
       - Use Tailwind classes for styling (keep it simple -- a card with key-value rows).

    4. Update src/main.tsx to expose dispatch to the browser console for testing:
       - After rendering, DO NOT expose dispatch directly from main.tsx (it's inside the provider).
       - Instead, in the AppContent component inside App.tsx, use a useEffect to attach dispatch to `window.__dispatch` and state to `window.__state`:
         ```typescript
         useEffect(() => {
           (window as any).__dispatch = dispatch;
           (window as any).__state = state;
         }, [dispatch, state]);
         ```
       - This allows testing from the browser console:
         ```
         __dispatch({ type: 'SET_ACTIVE_FIELD', fieldId: 'field-2' })
         __dispatch({ type: 'NEXT_FIELD' })
         __dispatch({ type: 'SET_ZOOM', zoom: 1.5 })
         __state  // inspect current state
         ```

    5. The debug display in AppContent should reactively update when state changes (dispatching from console should visibly change the rendered values).

    IMPORTANT: ValidationProvider is the single source of truth per the locked architecture decision. All state flows through this context.
  </action>
  <verify>
    Run `npm run dev` -- app starts without errors.
    Run `npx tsc --noEmit` -- zero TypeScript errors.
    Open browser console and test:
    1. `__state.activeFieldId` -- should return the first field's ID
    2. `__state.fieldOrder.length` -- should return 12+
    3. `__dispatch({ type: 'NEXT_FIELD' })` -- activeFieldId should change (verify via __state or the debug display)
    4. `__dispatch({ type: 'SET_ZOOM', zoom: 2.0 })` -- zoom should update to 2.0
    5. `__dispatch({ type: 'SET_ACTIVE_FIELD', fieldId: __state.fieldOrder[5] })` -- should jump to 6th field
  </verify>
  <done>
    ValidationProvider wraps the app and provides state + dispatch via context. useValidation hook works and throws if used outside provider. App.tsx shows a debug view with activeFieldId, zoom, fieldOrder.length, and isEditing. Browser console can dispatch SET_ACTIVE_FIELD, NEXT_FIELD, PREV_FIELD, SET_ZOOM, ZOOM_IN, ZOOM_OUT and see state updates reflected immediately in the UI. All TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. `npx tsc --noEmit` passes with zero errors
3. Browser shows debug view with state values
4. Console: `__dispatch({ type: 'SET_ACTIVE_FIELD', fieldId: __state.fieldOrder[3] })` changes activeFieldId in the debug display
5. Console: `__dispatch({ type: 'NEXT_FIELD' })` advances to next field
6. Console: `__dispatch({ type: 'PREV_FIELD' })` goes to previous field
7. Console: `__dispatch({ type: 'SET_ZOOM', zoom: 2.0 })` updates zoom display
8. Console: `__dispatch({ type: 'ZOOM_IN' })` and `__dispatch({ type: 'ZOOM_OUT' })` adjust zoom
9. Console: `__state.fieldOrder.length` returns 12 or more
</verification>

<success_criteria>
- ValidationProvider context is the single source of truth for the app
- All 11 action types are handled by the reducer with immutable updates
- fieldOrder is derived from the extraction result's field groups
- State changes are observable both via console (__state) and the rendered debug UI
- Phase 1 success criteria #4 is fully met: dispatching actions from browser console updates state correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
